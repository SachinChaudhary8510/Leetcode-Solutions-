# ğŸ”¢ LeetCode Problem - 2269. Find the K-Beauty of a Number

## ğŸš€ Problem Statement

> The **k-beauty** of an integer `num` is defined as the number of substrings of `num` when it is read as a string that meet the following conditions:
> 
> - It has a length of `k`.
> - It is a **divisor** of `num`.

ğŸ“ Notes:
- Leading zeros are allowed.
- `0` is not a divisor of any number.
- A substring is a contiguous sequence of characters in a string.

---

## ğŸ§© Examples

### âœ… Example 1:
```
Input: num = 240, k = 2
Output: 2

Substrings of length k:
- "24" â†’ âœ… divisor of 240
- "40" â†’ âœ… divisor of 240
```

### âœ… Example 2:
```
Input: num = 430043, k = 2
Output: 2

Substrings of length k:
- "43" â†’ âœ… divisor
- "30" â†’ âŒ
- "00" â†’ âŒ
- "04" â†’ âŒ
- "43" â†’ âœ… divisor
```

---

## ğŸ“Œ Constraints
- `1 <= num <= 10^9`
- `1 <= k <= num.length()` (num is treated as a string)

---

## ğŸ’¡ Intuition

The problem is about substring enumeration and modulus checks.

1. Extract every substring of length `k` from `num` (as string).
2. Convert each substring to integer.
3. If itâ€™s not zero and divides the original number â†’ it's counted as valid.

---

## ğŸ§‘â€ğŸ’» Java Solution
```java
class Solution {
    public int divisorSubstrings(int num, int k) {
        int num1 = num, count = 0;
        int d = 1;
        for (int i = 0; i < k; i++) {
            d *= 10;
        }
        while (num1 >= (d / 10)) {
            int r = num1 % d;
            if (r != 0 && num % r == 0)
                count++;
            num1 /= 10;
        }
        return count;
    }
}
```

---

## ğŸ Python Solution
```python
class Solution:
    def divisorSubstrings(self, num: int, k: int) -> int:
        s = str(num)
        count = 0
        for i in range(len(s) - k + 1):
            sub = int(s[i:i+k])
            if sub != 0 and num % sub == 0:
                count += 1
        return count
```

---

## ğŸ’» C++ Solution
```cpp
class Solution {
public:
    int divisorSubstrings(int num, int k) {
        string s = to_string(num);
        int count = 0;
        for (int i = 0; i <= s.size() - k; ++i) {
            int sub = stoi(s.substr(i, k));
            if (sub != 0 && num % sub == 0)
                count++;
        }
        return count;
    }
};
```

---

## ğŸ“ File Structure Suggestion
```
.
â”œâ”€â”€ README.md
â”œâ”€â”€ java
â”‚   â””â”€â”€ Solution.java
â”œâ”€â”€ python
â”‚   â””â”€â”€ solution.py
â””â”€â”€ cpp
    â””â”€â”€ solution.cpp
```

---

## ğŸ Summary
Elegant application of string parsing and number theory. This pattern of checking substrings against numeric properties has wide applications in validation and optimization problems.

---

ğŸ“š Keep solving, keep improving! ğŸ”  
