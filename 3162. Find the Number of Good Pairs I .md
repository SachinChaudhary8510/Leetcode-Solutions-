# ğŸ¤ LeetCode Problem - 3162. Find the Number of Good Pairs I

## ğŸš€ Problem Statement

> You are given two integer arrays `nums1` and `nums2` of lengths `n` and `m` respectively, and a positive integer `k`.  
> A pair `(i, j)` is called **good** if `nums1[i]` is divisible by `nums2[j] * k` (i.e., `nums1[i] % (nums2[j] * k) == 0`).  
> Return the total number of good pairs.

---

## ğŸ§© Examples

### âœ… Example 1:
```
Input: nums1 = [1, 3, 4], nums2 = [1, 3, 4], k = 1
Output: 5

Explanation:
Good pairs are:
(0, 0), (1, 0), (1, 1), (2, 0), (2, 2)
```

### âœ… Example 2:
```
Input: nums1 = [1, 2, 4, 12], nums2 = [2, 4], k = 3
Output: 2

Explanation:
Good pairs are:
(3, 0), (3, 1)
```

---

## ğŸ“Œ Constraints

- `1 <= n, m <= 50`
- `1 <= nums1[i], nums2[j] <= 50`
- `1 <= k <= 50`

---

## ğŸ’¡ Intuition

This is a brute-force friendly problem due to small input size:

1. Loop through every pair `(i, j)` in `nums1` Ã— `nums2`.
2. Check if `nums1[i]` is divisible by `nums2[j] * k`.
3. Count it if it is.

The naive nested loop solution is efficient enough here (max 2500 operations).

---

## ğŸ§‘â€ğŸ’» Java Solution
```java
class Solution {
    public int numberOfPairs(int[] nums1, int[] nums2, int k) {
        int count = 0;
        for (int i = 0; i < nums1.length; i++) {
            for (int j = 0; j < nums2.length; j++) {
                if (nums1[i] % (nums2[j] * k) == 0) {
                    count++;
                }
            }
        }
        return count;
    }
}
```

---

## ğŸ Python Solution
```python
class Solution:
    def numberOfPairs(self, nums1, nums2, k):
        count = 0
        for x in nums1:
            for y in nums2:
                if x % (y * k) == 0:
                    count += 1
        return count
```

---

## ğŸ’» C++ Solution
```cpp
class Solution {
public:
    int numberOfPairs(vector<int>& nums1, vector<int>& nums2, int k) {
        int count = 0;
        for (int a : nums1) {
            for (int b : nums2) {
                if (a % (b * k) == 0) {
                    count++;
                }
            }
        }
        return count;
    }
};
```

---

## ğŸ“ Suggested File Layout
```
.
â”œâ”€â”€ README.md
â”œâ”€â”€ java
â”‚   â””â”€â”€ Solution.java
â”œâ”€â”€ python
â”‚   â””â”€â”€ solution.py
â””â”€â”€ cpp
    â””â”€â”€ solution.cpp
```

---

## ğŸ§  Summary

This problem is a perfect candidate for direct iteration without optimization.  
Clean, readable code will outperform premature optimization here.

---

ğŸ“Š Brute-force isnâ€™t a sin â€” when the constraints bless it.  
