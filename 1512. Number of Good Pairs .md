# ğŸ‘¯â€â™‚ï¸ LeetCode Problem - 1512. Number of Good Pairs

## ğŸ“ Problem Statement

> Given an array of integers `nums`, return the number of **good pairs**.

A pair `(i, j)` is called **good** if:
- `nums[i] == nums[j]` and
- `i < j`

---

## ğŸ” Examples

### âœ… Example 1:
```
Input: nums = [1,2,3,1,1,3]
Output: 4
Explanation: The 4 good pairs are (0,3), (0,4), (3,4), (2,5)
```

### âœ… Example 2:
```
Input: nums = [1,1,1,1]
Output: 6
Explanation: All possible pairs are good.
```

### âœ… Example 3:
```
Input: nums = [1,2,3]
Output: 0
Explanation: No elements are repeated.
```

---

## ğŸ“Œ Constraints

- `1 <= nums.length <= 100`
- `1 <= nums[i] <= 100`

---

## ğŸ’¡ Intuition

This is a brute-force-friendly problem because of the small input limits.  
We're simply checking every possible pair and counting those that meet the condition.

---

## ğŸ§‘â€ğŸ’» Java Solution
```java
class Solution {
    public int numIdenticalPairs(int[] nums) {
        int count = 0;
        for (int i = 0; i < nums.length; i++) {
            for (int j = 0; j < nums.length; j++) {
                if (nums[i] == nums[j] && i < j)
                    count++;
            }
        }
        return count;
    }
}
```

---

## ğŸ Python Solution
```python
class Solution:
    def numIdenticalPairs(self, nums: List[int]) -> int:
        count = 0
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                if nums[i] == nums[j]:
                    count += 1
        return count
```

---

## ğŸ’» C++ Solution
```cpp
class Solution {
public:
    int numIdenticalPairs(vector<int>& nums) {
        int count = 0;
        for(int i = 0; i < nums.size(); i++) {
            for(int j = i + 1; j < nums.size(); j++) {
                if(nums[i] == nums[j])
                    count++;
            }
        }
        return count;
    }
};
```

---

## ğŸš€ Optimized Insight (Not implemented here)
- You can also use a hash map (or array counter) to count frequency of each number and apply the formula:  
  `pairs = (freq * (freq - 1)) / 2`

---

## ğŸ§  Summary

Simple problem that builds brute-force confidence and introduces pairwise logic.  
Scales well due to small constraints. Perfect for beginners.

---

ğŸ“ Suggested File Tree:
```
.
â”œâ”€â”€ README.md
â”œâ”€â”€ java/
â”‚   â””â”€â”€ Solution.java
â”œâ”€â”€ python/
â”‚   â””â”€â”€ solution.py
â””â”€â”€ cpp/
    â””â”€â”€ solution.cpp
```
