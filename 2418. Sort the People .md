# ğŸ§â€â™€ï¸ğŸ§â€â™‚ï¸ LeetCode Problem - 2418. Sort the People

## ğŸ“ Problem Statement

> You are given:
> - An array of strings `names`
> - An array of **distinct** positive integers `heights`

Both arrays are of equal length `n`.  
Each index `i` corresponds to a person â€” `names[i]` is their name, and `heights[i]` is their height.

Your task is to **return the names array sorted in descending order by their corresponding heights**.

---

## ğŸ” Examples

### âœ… Example 1:
```
Input: names = ["Mary","John","Emma"], heights = [180,165,170]
Output: ["Mary","Emma","John"]

Explanation:
Mary is the tallest (180), then Emma (170), and John (165).
```

### âœ… Example 2:
```
Input: names = ["Alice","Bob","Bob"], heights = [155,185,150]
Output: ["Bob","Alice","Bob"]
```

---

## ğŸ“Œ Constraints

- `n == names.length == heights.length`
- `1 <= n <= 10^3`
- `1 <= names[i].length <= 20`
- `1 <= heights[i] <= 10^5`
- `names[i]` consists of upper and lowercase English letters
- All `heights[i]` values are distinct

---

## ğŸ’¡ Intuition

The problem reduces to:
- Zip names and heights together
- Sort based on heights (descending)
- Extract names from the sorted pairs

---

## ğŸ§‘â€ğŸ’» Java Solution
```java
class Solution {
    public String[] sortPeople(String[] names, int[] heights) {
        int[] hei = heights.clone();
        Arrays.sort(hei);
        String[] namess = {};
        int count = 0;
        for (int i = 0; i < heights.length; i++) {
            for (int j = 0; j < heights.length; j++) {
                if (hei[hei.length - 1 - i] == heights[j]) {
                    namess = Arrays.copyOf(namess, namess.length + 1);
                    namess[namess.length - 1] = names[j];
                    count++;
                    continue;
                }
            }
        }
        return namess;
    }
}
```

---

## ğŸ Python Solution
```python
class Solution:
    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:
        people = list(zip(heights, names))
        people.sort(reverse=True)
        return [name for _, name in people]
```

---

## ğŸ’» C++ Solution
```cpp
class Solution {
public:
    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {
        vector<pair<int, string>> people;
        for (int i = 0; i < names.size(); ++i)
            people.emplace_back(heights[i], names[i]);
        
        sort(people.rbegin(), people.rend());
        
        vector<string> result;
        for (auto& [h, name] : people)
            result.push_back(name);
        
        return result;
    }
};
```

---

## ğŸ—‚ï¸ Suggested Project Structure
```
.
â”œâ”€â”€ README.md
â”œâ”€â”€ java/
â”‚   â””â”€â”€ Solution.java
â”œâ”€â”€ python/
â”‚   â””â”€â”€ solution.py
â””â”€â”€ cpp/
    â””â”€â”€ solution.cpp
```

---

## ğŸ§  Summary

Simple zip â†’ sort â†’ unzip pattern.  
Distinct heights make comparison easy â€” no duplicates to manage.

---

ğŸ“ Sorting with structure beats sorting in place.  
